"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lotus = void 0;
const uuid_1 = require("uuid");
const axios_1 = require("axios");
const axios_retry_1 = require("axios-retry");
const ms_1 = require("ms");
const event_validation_1 = require("./event-validation");
const data_types_1 = require("./data-types");
const noop = () => { };
const setImmediate = (functionToExecute, args) => {
    return functionToExecute(args);
};
const callReq = (req) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        return (0, axios_1.default)(req);
    }
    catch (error) {
        throw new Error(error);
    }
});
class Lotus {
    /**
     * Initialize a new `Lotus` with your Lotus organization's `apiKey` and an
     * optional dictionary of `options`.
     *
     * @param {String} apiKey
     * @param {Object} [options] (optional)
     *   @property {Number} flushAt (default: 20)
     *   @property {Number} flushInterval (default: 10000)
     *   @property {String} host (default: 'https://www.uselotus.app/')
     *   @property {Boolean} enable (default: true)
     */
    constructor(apiKey, options) {
        this.getRequestObject = (method, url, data, params) => {
            Object.keys(data).forEach((k) => data[k] == null && delete data[k]);
            Object.keys(params).forEach((p) => params[p] == null && delete data[p]);
            if (!data && params) {
                return {
                    method: method,
                    url: this.getRequestUrl(url),
                    headers: this.headers,
                    params: params,
                };
            }
            if (!params && data) {
                return {
                    method: method,
                    url: this.getRequestUrl(url),
                    headers: this.headers,
                    body: data,
                };
            }
            return {
                method: method,
                url: this.getRequestUrl(url),
                params: params,
                body: data,
                headers: this.headers,
            };
        };
        this.getRequestUrl = (url) => `${this.host}${url}`;
        this.setRequestTimeout = (req) => {
            if (this.timeout) {
                req["timeout"] =
                    typeof this.timeout === "string" ? (0, ms_1.default)(this.timeout) : this.timeout;
            }
        };
        options = options || {};
        if (!apiKey) {
            throw new Error("Api Key is required");
        }
        this.queue = [];
        this.apiKey = apiKey;
        const host_url = options.host || "https://api.uselotus.io/";
        this.host = host_url.replace(/\/$/, "");
        this.timeout = options.timeout || false;
        this.flushAt = Math.max(options.flushAt, 1) || 20;
        this.flushInterval =
            typeof options.flushInterval === "number" ? options.flushInterval : 10000;
        this.enable = typeof options.enable === "boolean" ? options.enable : true;
        this.headers = {
            "X-API-KEY": this.apiKey,
        };
        (0, axios_retry_1.default)(axios_1.default, {
            retries: options.retryCount || 3,
            retryCondition: this._isErrorRetryable,
            retryDelay: axios_retry_1.default.exponentialDelay,
        });
    }
    /**
     * Add a `message` of type `type` to the queue and
     * check whether it should be flushed.
     *
     * @param params
     * @param {Function} [callback] (optional)
     * @api private
     */
    enqueue(params, callback) {
        callback = callback || noop;
        if (!this.enable) {
            return setImmediate(callback);
        }
        params.batch.forEach((message) => {
            const data = {
                time_created: message.timeCreated || new Date(),
                idempotency_id: message.idempotencyId || (0, uuid_1.v4)(),
                customer_id: message.customerId,
                event_name: message.eventName,
            };
            if (message.properties) {
                data["properties"] = message.properties;
            }
            this.queue.push({ data, callback });
        });
        if (this.queue.length >= this.flushAt) {
            this.flush();
        }
        if (this.flushInterval && !this.timer) {
            this.timer = setTimeout(() => this.flush(), this.flushInterval);
        }
    }
    /**
     * Flush the current queue
     *
     * @param {Function} [callback] (optional)
     * @return {Lotus}
     */
    flush(callback) {
        callback = callback || noop;
        if (!this.enable) {
            return setImmediate(callback);
        }
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (!this.queue.length) {
            return setImmediate(callback);
        }
        const items = this.queue.splice(0, this.flushAt);
        // const callbacks = items.map(item => item.callback)
        // const messages = items.map(item => item.message)
        const data = {
            batch: items.map((item) => item.data),
        };
        // const done = (err?:any) => {
        //     callbacks.forEach((callback) => callback(err))
        //     callback(err, data)
        // }
        const req = this.getRequestObject(data_types_1.REQUEST_TYPES.POST, data_types_1.REQUEST_URLS.TRACK_EVENT, data);
        this.setRequestTimeout(req);
        return callReq(req);
    }
    /**
     * Send a trackEvent `message`.
     *
     * @param {Object} message (Should contain event name and customer id)
     * @param {Function} [callback] (optional)
     * @return {Lotus}
     */
    trackEvent(message, callback) {
        (0, event_validation_1.eventValidation)(message, data_types_1.ValidateEventType.trackEvent);
        const properties = Object.assign({}, message.properties, {
            $lib: "lotus-node",
        });
        const apiMessage = Object.assign({}, message, { properties });
        this.enqueue(apiMessage, callback);
        return this;
    }
    /**
     * Get All Customers.
     *
     * @return {Object} (Array of customers)
     */
    getCustomers() {
        return __awaiter(this, void 0, void 0, function* () {
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_CUSTOMERS);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Get Customer Detail.
     *
     * @return {Object}
     * @param message
     */
    getCustomerDetail(message) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(message, data_types_1.ValidateEventType.customerDetails);
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_CUSTOMER_DETAIL(message.customerId));
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Create a new Customer.
     *  @return {Object}
     * @param params
     *
     */
    createCustomer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.createCustomer);
            const data = {
                customer_id: params.customerId,
                customer_name: params.customerName,
                email: params.email,
                payment_provider: params.paymentProvider,
                payment_provider_id: params.paymentProviderId,
                properties: params.properties,
            };
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.POST, data_types_1.REQUEST_URLS.CREATE_CUSTOMERS, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Create customer batch.
     * @return {Object}
     * @param params
     *
     */
    createCustomersBatch(params) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.createCustomersBatch);
            const customers = params.customers.map((customer) => {
                return {
                    customer_id: customer.customerId,
                    customer_name: customer.customerName,
                    email: customer.email,
                    payment_provider: customer.paymentProvider,
                    payment_provider_id: customer.paymentProviderId,
                    properties: customer.properties,
                };
            });
            const data = {
                customers: customers,
                behavior_on_existing: params.behaviorOnExisting,
            };
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.POST, data_types_1.REQUEST_URLS.CREATE_BATCH_CUSTOMERS, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Create a new Subscription.
     *  @return {Object}
     *  @param params
     *
     */
    createSubscription(params) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.createSubscription);
            const data = {
                customer_id: params.customerId,
                plan_id: params.planId,
                start_date: params.startDate,
            };
            if (params.endDate) {
                data["end_date"] = params.endDate;
            }
            if (params.status) {
                data["status"] = params.status;
            }
            if (params.autoRenew) {
                data["auto_renew"] = params.autoRenew;
            }
            if (params.isNew) {
                data["is_new"] = params.isNew;
            }
            if (params.subscriptionId) {
                data["subscription_id"] = params.subscriptionId;
            }
            if ((_a = params.subscriptionFilters) === null || _a === void 0 ? void 0 : _a.length) {
                data["subscription_filters"] = (_b = params.subscriptionFilters) === null || _b === void 0 ? void 0 : _b.map((v) => {
                    return {
                        property_name: v.propertyName,
                        value: v.value,
                    };
                });
            }
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.POST, data_types_1.REQUEST_URLS.CREATE_SUBSCRIPTION, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Delete a new Subscription.
     *  @return {Object}
     *  @param params
     *
     */
    cancelSubscription(params) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.cancelSubscription);
            const data = {
                bill_usage: params.billUsage,
                flat_fee_behavior: params.flatFeeBehavior,
            };
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.DELETE, data_types_1.REQUEST_URLS.CANCEL_SUBSCRIPTION, null, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Change a Subscription.
     *
     * @param params
     *
     */
    changeSubscription(params) {
        var _a, _b;
        (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.changeSubscription);
        const data = {
            plan_id: params.planId || null,
            customer_id: params.customerId || false,
        };
        if ((_a = params.subscriptionFilters) === null || _a === void 0 ? void 0 : _a.length) {
            data["subscription_filters"] = (_b = params.subscriptionFilters) === null || _b === void 0 ? void 0 : _b.map((v) => {
                return {
                    property_name: v.propertyName,
                    value: v.value,
                };
            });
        }
        const newbody = {
            replace_plan_id: params.replacePlanId || null,
            turn_off_auto_renew: params.turnOffAutoRenew || null,
            replace_plan_invoicing_behavior: params.replacePlanInvoicingBehavior || null,
            end_date: params.endDate || null,
        };
        const req = this.getRequestObject(data_types_1.REQUEST_TYPES.PATCH, data_types_1.REQUEST_URLS.CHANGE_SUBSCRIPTION, data, newbody);
        this.setRequestTimeout(req);
        return callReq(req);
    }
    /**
     * Get all subscriptions.
     *
     */
    getAllSubscriptions(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let data;
            if (!!Object.keys(params).length) {
                data = {
                    customer_id: params.customerId || null,
                    status: params.status || null,
                };
            }
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_ALL_SUBSCRIPTIONS, null, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Get subscription details. subscription_id
     *
     * @param params
     *
     */
    getSubscriptionDetails(params) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.subscriptionDetails);
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_SUBSCRIPTION_DETAILS(params.subscriptionId));
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Get All plans.
     *
     */
    getAllPlans() {
        return __awaiter(this, void 0, void 0, function* () {
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_ALL_PLANS);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Get customer feature access.
     *
     * @param params
     *
     */
    getCustomerFeatureAccess(params) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.customerFeatureAccess);
            const data = {
                customer_id: params.customerId,
                feature_name: params.featureName,
            };
            if ((_a = params.subscriptionFilters) === null || _a === void 0 ? void 0 : _a.length) {
                data["subscription_filters"] = (_b = params.subscriptionFilters) === null || _b === void 0 ? void 0 : _b.map((v) => {
                    return {
                        property_name: v.propertyName,
                        value: v.value,
                    };
                });
            }
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_CUSTOMER_FEATURE_ACCESS, null, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Get customer access.
     *
     * @param params
     *
     */
    getCustomerMetricAccess(params) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.customerMetricAccess);
            const data = {
                customer_id: params.customerId,
                event_name: params.eventName,
            };
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_CUSTOMER_METRIC_ACCESS, null, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    /**
     * Get invoices.
     *
     * @param params
     *
     */
    getInvoices(params) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, event_validation_1.eventValidation)(params, data_types_1.ValidateEventType.getInvoices);
            const data = {
                customer_id: params.customerId || null,
                payment_status: params.paymentStatus || null,
            };
            const req = this.getRequestObject(data_types_1.REQUEST_TYPES.GET, data_types_1.REQUEST_URLS.GET_CUSTOMER_METRIC_ACCESS, null, data);
            this.setRequestTimeout(req);
            return callReq(req);
        });
    }
    _isErrorRetryable(error) {
        // Retry Network Errors.
        if (axios_retry_1.default.isNetworkError(error)) {
            return true;
        }
        if (!error.response) {
            // Cannot determine if the request can be retried
            return false;
        }
        // Retry Server Errors (5xx).
        if (error.response.status >= 500 && error.response.status <= 599) {
            return true;
        }
        // Retry if rate limited.
        return error.response.status === 429;
    }
}
exports.Lotus = Lotus;
