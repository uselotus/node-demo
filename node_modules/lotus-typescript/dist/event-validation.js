"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eventValidation = void 0;
const data_types_1 = require("./data-types");
/**
 * Validate an event.
 */
function eventValidation(event, type) {
    switch (type) {
        case data_types_1.ValidateEventType.createCustomer:
            return validateCreateCustomerEvent(event);
        case data_types_1.ValidateEventType.customerDetails:
            return validateCustomerDetailsEvent(event);
        case data_types_1.ValidateEventType.createSubscription:
            return validateCreateSubscriptionEvent(event);
        case data_types_1.ValidateEventType.cancelSubscription:
            return validateCancelSubscriptionEvent(event);
        case data_types_1.ValidateEventType.changeSubscription:
            return validateChangeSubscriptionEvent(event);
        case data_types_1.ValidateEventType.subscriptionDetails:
            return validateSubscriptionDetailsEvent(event);
        case data_types_1.ValidateEventType.customerAccess:
            return validateCustomerAccessEvent(event);
        case data_types_1.ValidateEventType.trackEvent:
            return validateTrackEventEvent(event);
        case data_types_1.ValidateEventType.createCustomersBatch:
            return validateCreateCustomersBatchEvent(event);
        default:
            throw new Error("Invalid Event Type");
    }
}
exports.eventValidation = eventValidation;
/**
 * Validate a "CreateCustomer" event.
 */
function validateCreateCustomerEvent(event) {
   if (!event.customerId) {
        throw new Error("customerId Name is a required key")
    }

    if (!event.email) {
        throw new Error("Email is a required key")
    }
}
/**
 * Validate a "CreateCustomersBatch" event.
 */
function validateCreateCustomersBatchEvent(event) {
    const customers = event.customers || [];
    const behaviorOnExisting = event.behaviorOnExisting;
    if (!customers || !customers.length) {
        throw new Error("Customers is a required array");
    }
    customers.forEach((customer, index) => {
        if (!customer.customerId) {
            throw new Error(`customerId is a required key, Missing in ${index + 1} customer`);
        }
        if (!customer.email) {
            throw new Error(`email is a required key, Missing in ${index + 1} customer`);
        }
    });
    if (!behaviorOnExisting) {
        throw new Error(`behaviorOnExisting is a required key`);
    }
    const allowed_types = ["merge", "ignore", "overwrite"];
    if (!allowed_types.includes(behaviorOnExisting)) {
        throw new Error(`behaviorOnExisting Must be one the these "merge","ignore", "overwrite"`);
    }
}
/**
 * Validate a "CustomerDetails" event.
 */
function validateCustomerDetailsEvent(event) {
    if (!event.customerId) {
        throw new Error("customerId is a required key");
    }
}
/**
 * Validate a "CreateSubscription" event.
 */
function validateCreateSubscriptionEvent(event) {
    if (!event.customerId) {
        throw new Error("customerId is a required key");
    }
    if (!event.planId) {
        throw new Error("planId is a required key");
    }
    if (!event.startDate) {
        throw new Error("startDate is a required key");
    }
}
/**
 * Validate a "CancelSubscription" event.
 */
function validateCancelSubscriptionEvent(event) {
    const subscriptionId = event.subscriptionId;
    const turnOffAutoRenew = event.turnOffAutoRenew;
    const replaceImmediatelyType = event.replaceImmediatelyType;
    if (!subscriptionId) {
        throw new Error("subscription_id is a required key");
    }
    if (turnOffAutoRenew && replaceImmediatelyType) {
        throw new Error("Must provide either turnOffAutoRenew or replaceImmediatelyType");
    }
    if (!turnOffAutoRenew) {
        const types = [
            "end_current_subscription_and_bill",
            "end_current_subscription_dont_bill",
        ];
        if (!types.includes(replaceImmediatelyType)) {
            throw new Error("replaceImmediatelyType must be one of 'end_current_subscription_and_bill', 'end_current_subscription_dont_bill'");
        }
    }
}
/**
 * Validate a "ChangeSubscription" event.
 */
function validateChangeSubscriptionEvent(event) {
    if (!event.subscriptionId) {
        throw new Error("subscriptionId is a required key");
    }
    if (!event.planId) {
        throw new Error("planId is a required key");
    }
    const replace_immediately_type = event.replaceImmediatelyType;
    const types = [
        "end_current_subscription_and_bill",
        "end_current_subscription_dont_bill",
        "change_subscription_plan"
    ];
    if (!replace_immediately_type) {
        throw new Error("replaceImmediatelyType is a required key");
    }
    if (!types.includes(replace_immediately_type)) {
        throw new Error("Invalid replace_immediately_type");
    }
}
/**
 * Validate a "SubscriptionDetails" event.
 */
function validateSubscriptionDetailsEvent(event) {
    if (!event.subscriptionId) {
        throw new Error("subscription_id is a required key");
    }
}
/**
 * Validate a "Customer Access" event.
 */
function validateCustomerAccessEvent(event) {
    if (!event.customerId) {
        throw new Error("customerId is a required key");
    }
    if (event.eventName && event.featureName) {
        throw new Error("Can't provide both featureName and eventName");
    }
    if (!event.eventName && !event.featureName) {
        throw new Error("Must provide featureName or eventName");
    }
}
/**
 * Validate a "trackEvent" event.
 */
function validateTrackEventEvent(event) {
    if (!event.batch || !event.batch.length) {
        throw new Error("Messages batch can't be empty");
    }
    event.batch.forEach(messaage => {
        if (!messaage.customerId) {
            throw new Error("customerId is a required key");
        }
        if (!messaage.eventName) {
            throw new Error("eventName is a required key");
        }
    });
}
