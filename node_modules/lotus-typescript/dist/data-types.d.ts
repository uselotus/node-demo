export declare enum REQUEST_TYPES {
    GET = "GET",
    POST = "POST",
    PATCH = "PATCH",
    DELETE = "DELETE"
}
export declare const REQUEST_URLS: {
    GET_CUSTOMERS: string;
    CREATE_CUSTOMERS: string;
    CREATE_BATCH_CUSTOMERS: string;
    GET_CUSTOMER_DETAIL: (customerId: any) => string;
    CREATE_SUBSCRIPTION: string;
    CANCEL_SUBSCRIPTION: string;
    CHANGE_SUBSCRIPTION: string;
    GET_ALL_SUBSCRIPTIONS: string;
    GET_SUBSCRIPTION_DETAILS: (subscriptionId: any) => string;
    GET_ALL_PLANS: string;
    GET_CUSTOMER_FEATURE_ACCESS: string;
    GET_CUSTOMER_METRIC_ACCESS: string;
    TRACK_EVENT: string;
    GET_INVOICES: string;
};
export declare enum ValidateEventType {
    createCustomer = "createCustomer",
    trackEvent = "trackEvent",
    customerDetails = "customerDetails",
    createSubscription = "createSubscription",
    cancelSubscription = "cancelSubscription",
    changeSubscription = "changeSubscription",
    subscriptionDetails = "subscriptionDetails",
    customerMetricAccess = "customerMetricAccess",
    customerFeatureAccess = "customerFeatureAccess",
    createCustomersBatch = "createCustomersBatch",
    getInvoices = "getInvoices"
}
export interface CreateCustomerParams {
    customerId: string;
    email: string;
    paymentProvider?: string;
    paymentProviderId?: string;
    customerName?: string;
    properties?: string;
    integrations?: string;
    default_currency_code?: string;
}
export interface CreateBatchCustomerParams {
    customers: CreateCustomerParams[];
    behaviorOnExisting: "merge" | "ignore" | "overwrite";
}
export interface CustomerDetailsParams {
    customerId: string;
}
export interface CustomerDetailsParams {
    customerId: string;
}
export interface subscriptionFilters {
    propertyName: string;
    value: string;
}
export interface CreateSubscriptionParams {
    customerId: string;
    planId: string;
    startDate: string;
    endDate?: string;
    status?: string;
    autoRenew?: boolean;
    isNew?: boolean;
    subscriptionId?: string;
    subscriptionFilters?: subscriptionFilters[];
}
export interface ChangeSubscriptionParams {
    customerId: string;
    planId?: string;
    subscriptionFilters?: subscriptionFilters[];
    replacePlanId?: string;
    replacePlanInvoicingBehavior?: "add_to_next_invoice" | "invoice_now";
    turnOffAutoRenew?: boolean;
    endDate?: string;
}
export interface SubscriptionDetailsParams {
    subscriptionId: string;
}
export interface CustomerMetricAccessParams {
    customerId: string;
    eventName?: string;
    subscriptionFilters?: subscriptionFilters[];
}
export interface CustomerMetricAccessResponse {
    event_name: string;
    subscription_id: string;
    subscription_filters: subscriptionFilters[];
    subscription_has_event: boolean;
    usage_per_metric: {
        metric_name: string;
        metric_id: string;
        metric_usage: number;
        metric_free_limit: number;
        metric_total_limit: number;
    }[];
}
export interface CustomerFeatureAccess {
    customerId: string;
    featureName?: string;
    subscriptionFilters?: subscriptionFilters[];
}
export interface CustomerFeatureAccessResponse {
    feature: string;
    subscription_id: string;
    subscription_filters: subscriptionFilters[];
    access: boolean;
}
export interface TrackEventEntity {
    eventName: string;
    customerId: string;
    idempotencyId: string;
    timeCreated: Date;
    properties?: any;
}
export interface TrackEvent {
    batch: TrackEventEntity[];
}
export interface ListAllSubscriptionsParams {
    customerId?: string;
    status?: "active" | "ended" | "not_started";
}
export interface CancelSubscriptionParams {
    planId: string;
    billUsage?: boolean;
    customerId: string;
    invoicingBehaviorOnCancel?: "add_to_next_invoice" | "invoice_now";
    flatFeeBehavior?: "refund" | "prorate" | "charge_full";
    subscriptionFilters?: subscriptionFilters[];
}
export interface GetInvoicesParams {
    customerId?: string;
    paymentStatus?: "paid" | "unpaid";
}
